import _toConsumableArray from '@babel/runtime/helpers/esm/toConsumableArray';
import _asyncToGenerator from '@babel/runtime/helpers/esm/asyncToGenerator';
import _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';
import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import { createReactQueryHooks, createTRPCClient } from '@trpc/react';
import React, { useState, createElement } from 'react';
import { QueryClient, QueryClientProvider, Hydrate, dehydrate } from 'react-query';
import ssrPrepass from 'react-ssr-prepass';

function transformQueryOrMutationCacheErrors(result) {
  var error = result.state.error;

  if (error instanceof Error && error.name === 'TRPCClientError') {
    var newError = {
      message: error.message,
      data: error.data,
      shape: error.shape
    };
    return _objectSpread(_objectSpread({}, result), {}, {
      state: _objectSpread(_objectSpread({}, result.state), {}, {
        error: newError
      })
    });
  }

  return result;
}

function withTRPC(opts) {
  var getClientConfig = opts.config;
  return function (AppOrPage) {
    var trpc = createReactQueryHooks();

    var WithTRPC = function WithTRPC(props) {
      var _props$pageProps;

      var _useState = useState(function () {
        if (props.trpc) {
          return props.trpc;
        }

        var config = getClientConfig({});
        var queryClient = new QueryClient(config.queryClientConfig);
        var trpcClient = trpc.createClient(config);
        return {
          queryClient: queryClient,
          trpcClient: trpcClient,
          ssrState: opts.ssr ? 'mounting' : false,
          ssrContext: null
        };
      }),
          _useState2 = _slicedToArray(_useState, 1),
          _useState2$ = _useState2[0],
          queryClient = _useState2$.queryClient,
          trpcClient = _useState2$.trpcClient,
          ssrState = _useState2$.ssrState,
          ssrContext = _useState2$.ssrContext;

      var hydratedState = trpc.useDehydratedState(trpcClient, (_props$pageProps = props.pageProps) === null || _props$pageProps === void 0 ? void 0 : _props$pageProps.trpcState);
      return /*#__PURE__*/React.createElement(trpc.Provider, {
        client: trpcClient,
        queryClient: queryClient,
        ssrState: ssrState,
        ssrContext: ssrContext
      }, /*#__PURE__*/React.createElement(QueryClientProvider, {
        client: queryClient
      }, /*#__PURE__*/React.createElement(Hydrate, {
        state: hydratedState
      }, /*#__PURE__*/React.createElement(AppOrPage, props))));
    };

    if (AppOrPage.getInitialProps || opts.ssr) {
      WithTRPC.getInitialProps = /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(appOrPageCtx) {
          var _opts$responseMeta;

          var AppTree, isApp, ctx, pageProps, _originalProps$pagePr, originalProps, originalPageProps, getAppTreeProps, config, trpcClient, queryClient, trpcProp, prepassProps, dehydratedCache, dehydratedCacheWithErrors, appTreeProps, meta, _i, _Object$entries, _Object$entries$_i, key, value, _ctx$res;

          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  AppTree = appOrPageCtx.AppTree; // Determine if we are wrapping an App component or a Page component.

                  isApp = !!appOrPageCtx.Component;
                  ctx = isApp ? appOrPageCtx.ctx : appOrPageCtx; // Run the wrapped component's getInitialProps function.

                  pageProps = {};

                  if (!AppOrPage.getInitialProps) {
                    _context.next = 10;
                    break;
                  }

                  _context.next = 7;
                  return AppOrPage.getInitialProps(appOrPageCtx);

                case 7:
                  originalProps = _context.sent;
                  originalPageProps = isApp ? (_originalProps$pagePr = originalProps.pageProps) !== null && _originalProps$pagePr !== void 0 ? _originalProps$pagePr : {} : originalProps;
                  pageProps = _objectSpread(_objectSpread({}, originalPageProps), pageProps);

                case 10:
                  getAppTreeProps = function getAppTreeProps(props) {
                    return isApp ? {
                      pageProps: props
                    } : props;
                  };

                  if (!(typeof window !== 'undefined' || !opts.ssr)) {
                    _context.next = 13;
                    break;
                  }

                  return _context.abrupt("return", getAppTreeProps(pageProps));

                case 13:
                  config = getClientConfig({
                    ctx: ctx
                  });
                  trpcClient = createTRPCClient(config);
                  queryClient = new QueryClient(config.queryClientConfig);
                  trpcProp = {
                    config: config,
                    trpcClient: trpcClient,
                    queryClient: queryClient,
                    ssrState: 'prepass',
                    ssrContext: ctx
                  };
                  prepassProps = {
                    pageProps: pageProps,
                    trpc: trpcProp
                  }; // Run the prepass step on AppTree. This will run all trpc queries on the server.
                  // multiple prepass ensures that we can do batching on the server

                case 18:

                  _context.next = 21;
                  return ssrPrepass( /*#__PURE__*/createElement(AppTree, prepassProps));

                case 21:
                  if (queryClient.isFetching()) {
                    _context.next = 23;
                    break;
                  }

                  return _context.abrupt("break", 27);

                case 23:
                  _context.next = 25;
                  return new Promise(function (resolve) {
                    var unsub = queryClient.getQueryCache().subscribe(function (event) {
                      if ((event === null || event === void 0 ? void 0 : event.query.getObserversCount()) === 0) {
                        resolve();
                        unsub();
                      }
                    });
                  });

                case 25:
                  _context.next = 18;
                  break;

                case 27:
                  dehydratedCache = dehydrate(queryClient, {
                    shouldDehydrateQuery: function shouldDehydrateQuery() {
                      // makes sure errors are also dehydrated
                      return true;
                    }
                  }); // since error instances can't be serialized, let's make them into `TRPCClientErrorLike`-objects

                  dehydratedCacheWithErrors = _objectSpread(_objectSpread({}, dehydratedCache), {}, {
                    queries: dehydratedCache.queries.map(transformQueryOrMutationCacheErrors),
                    mutations: dehydratedCache.mutations.map(transformQueryOrMutationCacheErrors)
                  }); // dehydrate query client's state and add it to the props

                  pageProps.trpcState = trpcClient.runtime.transformer.serialize(dehydratedCacheWithErrors);
                  appTreeProps = getAppTreeProps(pageProps);
                  meta = ((_opts$responseMeta = opts.responseMeta) === null || _opts$responseMeta === void 0 ? void 0 : _opts$responseMeta.call(opts, {
                    ctx: ctx,
                    clientErrors: [].concat(_toConsumableArray(dehydratedCache.queries), _toConsumableArray(dehydratedCache.mutations)).map(function (v) {
                      return v.state.error;
                    }).flatMap(function (err) {
                      return err instanceof Error && err.name === 'TRPCClientError' ? [err] : [];
                    })
                  })) || {};

                  for (_i = 0, _Object$entries = Object.entries(meta.headers || {}); _i < _Object$entries.length; _i++) {
                    _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];

                    if (typeof value === 'string') {
                      (_ctx$res = ctx.res) === null || _ctx$res === void 0 ? void 0 : _ctx$res.setHeader(key, value);
                    }
                  }

                  if (meta.status && ctx.res) {
                    ctx.res.statusCode = meta.status;
                  }

                  return _context.abrupt("return", appTreeProps);

                case 35:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }();
    }

    var displayName = AppOrPage.displayName || AppOrPage.name || 'Component';
    WithTRPC.displayName = "withTRPC(".concat(displayName, ")");
    return WithTRPC;
  };
}

export { withTRPC };
